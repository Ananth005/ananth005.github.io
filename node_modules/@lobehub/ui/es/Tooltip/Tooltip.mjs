'use client';

import { antdPlacementToFloating } from "./antdPlacementToFloating.mjs";
import { composeEventHandlers } from "../utils/composeEventHandlers.mjs";
import TooltipFloating_default from "./TooltipFloating.mjs";
import TooltipPortal_default from "./TooltipPortal.mjs";
import { TooltipGroupApiContext, TooltipGroupPropsContext } from "./groupContext.mjs";
import { cloneElement, isValidElement, useContext, useEffect, useMemo, useRef, useState } from "react";
import { Fragment as Fragment$1, jsx, jsxs } from "react/jsx-runtime";
import { arrow, autoUpdate, flip, offset, shift, useDismiss, useFloating, useFocus, useHover, useInteractions, useRole } from "@floating-ui/react";
import { mergeRefs } from "react-merge-refs";

//#region src/Tooltip/Tooltip.tsx
const TooltipInGroup = ({ ref, hotkey, className, arrow: arrow$1, title, hotkeyProps, children, placement, openDelay, closeDelay, mouseEnterDelay, mouseLeaveDelay, onOpenChange, disabled, classNames, styles: styleProps, zIndex, portalled, getPopupContainer }) => {
	const group = useContext(TooltipGroupApiContext);
	const sharedProps = useContext(TooltipGroupPropsContext);
	const triggerElRef = useRef(null);
	const mergedClassName = useMemo(() => {
		if (!sharedProps?.className && !className) return void 0;
		return [sharedProps?.className, className].filter(Boolean).join(" ");
	}, [className, sharedProps?.className]);
	const mergedClassNames = useMemo(() => {
		if (!sharedProps?.classNames && !classNames) return void 0;
		return {
			...sharedProps?.classNames,
			...classNames
		};
	}, [classNames, sharedProps?.classNames]);
	const mergedStyles = useMemo(() => {
		if (!sharedProps?.styles && !styleProps) return void 0;
		return {
			...sharedProps?.styles,
			...styleProps
		};
	}, [sharedProps?.styles, styleProps]);
	const mergedHotkeyProps = useMemo(() => {
		if (!sharedProps?.hotkeyProps && !hotkeyProps) return void 0;
		return {
			...sharedProps?.hotkeyProps,
			...hotkeyProps
		};
	}, [hotkeyProps, sharedProps?.hotkeyProps]);
	const mergedOnOpenChange = useMemo(() => {
		if (!sharedProps?.onOpenChange && !onOpenChange) return void 0;
		return (open) => {
			sharedProps?.onOpenChange?.(open);
			onOpenChange?.(open);
		};
	}, [onOpenChange, sharedProps?.onOpenChange]);
	const item = useMemo(() => ({
		arrow: arrow$1 ?? sharedProps?.arrow ?? false,
		className: mergedClassName,
		classNames: mergedClassNames,
		closeDelay: closeDelay ?? sharedProps?.closeDelay,
		disabled: disabled ?? sharedProps?.disabled,
		getPopupContainer: getPopupContainer ?? sharedProps?.getPopupContainer,
		hotkey: hotkey ?? sharedProps?.hotkey,
		hotkeyProps: mergedHotkeyProps,
		mouseEnterDelay: mouseEnterDelay ?? sharedProps?.mouseEnterDelay,
		mouseLeaveDelay: mouseLeaveDelay ?? sharedProps?.mouseLeaveDelay,
		onOpenChange: mergedOnOpenChange,
		openDelay: openDelay ?? sharedProps?.openDelay,
		placement: placement ?? sharedProps?.placement ?? "top",
		portalled: portalled ?? sharedProps?.portalled,
		styles: mergedStyles,
		title,
		zIndex: zIndex ?? sharedProps?.zIndex
	}), [
		arrow$1,
		closeDelay,
		disabled,
		getPopupContainer,
		hotkey,
		mergedClassName,
		mergedClassNames,
		mergedHotkeyProps,
		mergedOnOpenChange,
		mergedStyles,
		mouseEnterDelay,
		mouseLeaveDelay,
		openDelay,
		placement,
		portalled,
		sharedProps?.arrow,
		sharedProps?.closeDelay,
		sharedProps?.disabled,
		sharedProps?.getPopupContainer,
		sharedProps?.hotkey,
		sharedProps?.mouseEnterDelay,
		sharedProps?.mouseLeaveDelay,
		sharedProps?.openDelay,
		sharedProps?.placement,
		sharedProps?.portalled,
		sharedProps?.zIndex,
		title,
		zIndex
	]);
	const trigger = useMemo(() => {
		if (!isValidElement(children)) return /* @__PURE__ */ jsx("span", { children });
		if (typeof children.type === "string" && Boolean(children.props?.disabled)) return /* @__PURE__ */ jsx("span", {
			style: { display: "inline-flex" },
			children
		});
		return children;
	}, [children]);
	const referenceNode = useMemo(() => {
		if (!isValidElement(trigger)) return trigger;
		const originalRef = trigger.ref;
		const triggerProps = trigger.props || {};
		const setTriggerEl = (node) => {
			triggerElRef.current = node instanceof HTMLElement ? node : null;
		};
		return cloneElement(trigger, {
			...triggerProps,
			onBlur: composeEventHandlers(triggerProps.onBlur, (e) => {
				group?.closeFromTrigger(e.currentTarget, item);
			}),
			onFocus: composeEventHandlers(triggerProps.onFocus, (e) => {
				group?.openFromTrigger(e.currentTarget, item);
			}),
			onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (e) => {
				if (e?.key === "Escape") group?.closeImmediately();
			}),
			onPointerEnter: composeEventHandlers(triggerProps.onPointerEnter, (e) => {
				group?.openFromTrigger(e.currentTarget, item);
			}),
			onPointerLeave: composeEventHandlers(triggerProps.onPointerLeave, (e) => {
				group?.closeFromTrigger(e.currentTarget, item);
			}),
			ref: mergeRefs([
				originalRef,
				setTriggerEl,
				ref
			])
		});
	}, [
		group,
		item,
		ref,
		trigger
	]);
	useEffect(() => {
		return () => {
			if (!group) return;
			const el = triggerElRef.current;
			if (el && group.isActiveTrigger(el)) group.closeImmediately();
		};
	}, [group]);
	return referenceNode;
};
TooltipInGroup.displayName = "TooltipInGroup";
const TooltipStandalone = ({ ref, hotkey, className, arrow: arrow$1 = false, title, hotkeyProps, children, placement = "top", openDelay, closeDelay, mouseEnterDelay, mouseLeaveDelay, open, defaultOpen, onOpenChange, disabled, classNames, styles: styleProps, zIndex, portalled = true, getPopupContainer }) => {
	const arrowRef = useRef(null);
	const [uncontrolledOpen, setUncontrolledOpen] = useState(Boolean(defaultOpen));
	const mergedOpen = open ?? uncontrolledOpen;
	const setOpen = (next) => {
		if (open === void 0) setUncontrolledOpen(next);
		onOpenChange?.(next);
	};
	const floatingPlacement = useMemo(() => antdPlacementToFloating(placement), [placement]);
	const { context, floatingStyles, refs } = useFloating({
		middleware: useMemo(() => {
			const base = [
				offset(8),
				flip(),
				shift({ padding: 8 })
			];
			if (arrow$1) base.push(arrow({ element: arrowRef }));
			return base;
		}, [arrow$1]),
		onOpenChange: setOpen,
		open: disabled ? false : mergedOpen,
		placement: floatingPlacement,
		whileElementsMounted: autoUpdate
	});
	const { getFloatingProps, getReferenceProps } = useInteractions([
		useHover(context, {
			delay: useMemo(() => ({
				close: closeDelay ?? (mouseLeaveDelay !== void 0 ? mouseLeaveDelay * 1e3 : 100),
				open: openDelay ?? (mouseEnterDelay !== void 0 ? mouseEnterDelay * 1e3 : 400)
			}), [
				closeDelay,
				mouseEnterDelay,
				mouseLeaveDelay,
				openDelay
			]),
			enabled: !disabled,
			move: false
		}),
		useFocus(context, { enabled: !disabled }),
		useDismiss(context, { enabled: !disabled }),
		useRole(context, { role: "tooltip" })
	]);
	const trigger = useMemo(() => {
		if (!isValidElement(children)) return /* @__PURE__ */ jsx("span", { children });
		if (typeof children.type === "string" && Boolean(children.props?.disabled)) return /* @__PURE__ */ jsx("span", {
			style: { display: "inline-flex" },
			children
		});
		return children;
	}, [children]);
	const referenceNode = useMemo(() => {
		if (!isValidElement(trigger)) return trigger;
		const originalRef = trigger.ref;
		return cloneElement(trigger, getReferenceProps({
			...trigger.props,
			ref: mergeRefs([
				originalRef,
				refs.setReference,
				ref
			])
		}));
	}, [
		getReferenceProps,
		ref,
		refs.setReference,
		trigger
	]);
	const portalRoot = getPopupContainer && refs.reference.current ? getPopupContainer(refs.reference.current) : void 0;
	const floatingNode = /* @__PURE__ */ jsx(TooltipFloating_default, {
		arrow: arrow$1,
		arrowRef,
		className,
		classNames,
		context,
		floatingProps: getFloatingProps(),
		floatingStyles,
		hotkey,
		hotkeyProps,
		open: mergedOpen,
		placement: floatingPlacement,
		setFloating: refs.setFloating,
		styles: styleProps,
		title,
		zIndex
	});
	return /* @__PURE__ */ jsxs(Fragment$1, { children: [referenceNode, !disabled && title && (portalled ? /* @__PURE__ */ jsx(TooltipPortal_default, {
		root: portalRoot,
		children: floatingNode
	}) : floatingNode)] });
};
const Tooltip = (props) => {
	const group = useContext(TooltipGroupApiContext);
	return Boolean(group) && props.open === void 0 && props.defaultOpen === void 0 ? /* @__PURE__ */ jsx(TooltipInGroup, { ...props }) : /* @__PURE__ */ jsx(TooltipStandalone, { ...props });
};
var Tooltip_default = Tooltip;

//#endregion
export { Tooltip_default as default };
//# sourceMappingURL=Tooltip.mjs.map