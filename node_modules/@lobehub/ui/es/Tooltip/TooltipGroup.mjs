'use client';

import { antdPlacementToFloating } from "./antdPlacementToFloating.mjs";
import TooltipFloating_default from "./TooltipFloating.mjs";
import TooltipPortal_default from "./TooltipPortal.mjs";
import { TooltipGroupApiContext, TooltipGroupPropsContext } from "./groupContext.mjs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
import { arrow, autoUpdate, flip, offset, shift, useFloating } from "@floating-ui/react";

//#region src/Tooltip/TooltipGroup.tsx
const TooltipGroup = ({ children, ...sharedProps }) => {
	const arrowRef = useRef(null);
	const openTimerRef = useRef(null);
	const closeTimerRef = useRef(null);
	const [active, setActive] = useState(null);
	const [open, setOpen] = useState(false);
	const activeRef = useRef(null);
	useEffect(() => {
		activeRef.current = active;
	}, [active]);
	const floatingPlacement = useMemo(() => antdPlacementToFloating(active?.item.placement), [active?.item.placement]);
	const { context, floatingStyles, refs } = useFloating({
		middleware: useMemo(() => {
			const base = [
				offset(8),
				flip(),
				shift({ padding: 8 })
			];
			if (active?.item.arrow) base.push(arrow({ element: arrowRef }));
			return base;
		}, [active?.item.arrow]),
		open,
		placement: floatingPlacement,
		whileElementsMounted: autoUpdate
	});
	useEffect(() => {
		if (!active?.triggerEl) return;
		refs.setReference(active.triggerEl);
	}, [active?.triggerEl, refs]);
	const clearTimers = useCallback(() => {
		if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
		if (closeTimerRef.current) window.clearTimeout(closeTimerRef.current);
		openTimerRef.current = null;
		closeTimerRef.current = null;
	}, []);
	const closeImmediately = useCallback(() => {
		clearTimers();
		setOpen(false);
		activeRef.current?.item.onOpenChange?.(false);
	}, [clearTimers]);
	const destroyActive = useCallback(() => {
		clearTimers();
		setOpen(false);
		activeRef.current?.item.onOpenChange?.(false);
		setActive(null);
	}, [clearTimers]);
	const isActiveTrigger = useCallback((triggerEl) => {
		return Boolean(activeRef.current && activeRef.current.triggerEl === triggerEl);
	}, []);
	const closeFromTrigger = useCallback((triggerEl, item) => {
		if (!activeRef.current || activeRef.current.triggerEl !== triggerEl) return;
		clearTimers();
		const delayMs = item.closeDelay ?? (item.mouseLeaveDelay !== void 0 ? item.mouseLeaveDelay * 1e3 : 100);
		if (delayMs <= 0) {
			setOpen(false);
			item.onOpenChange?.(false);
			return;
		}
		closeTimerRef.current = window.setTimeout(() => {
			setOpen(false);
			item.onOpenChange?.(false);
		}, delayMs);
	}, [clearTimers]);
	const openFromTrigger = useCallback((triggerEl, item) => {
		if (!triggerEl) return;
		if (!item.title) return;
		if (item.disabled) return;
		clearTimers();
		setActive({
			item,
			triggerEl
		});
		const delayMs = item.openDelay ?? (item.mouseEnterDelay !== void 0 ? item.mouseEnterDelay * 1e3 : 100);
		if (delayMs <= 0) {
			if (!triggerEl.isConnected) {
				destroyActive();
				return;
			}
			setOpen(true);
			item.onOpenChange?.(true);
			return;
		}
		openTimerRef.current = window.setTimeout(() => {
			if (!triggerEl.isConnected) {
				destroyActive();
				return;
			}
			setOpen(true);
			item.onOpenChange?.(true);
		}, delayMs);
	}, [clearTimers, destroyActive]);
	const groupApi = useMemo(() => ({
		closeFromTrigger,
		closeImmediately,
		isActiveTrigger,
		openFromTrigger
	}), [
		closeFromTrigger,
		closeImmediately,
		isActiveTrigger,
		openFromTrigger
	]);
	useEffect(() => {
		if (!open) return;
		const triggerEl = active?.triggerEl;
		if (!triggerEl) return;
		if (!triggerEl.isConnected) {
			destroyActive();
			return;
		}
		const root = triggerEl.getRootNode?.();
		const observeTarget = typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot ? root : triggerEl.ownerDocument ?? document;
		const observer = new MutationObserver(() => {
			if (!triggerEl.isConnected) destroyActive();
		});
		observer.observe(observeTarget, {
			childList: true,
			subtree: true
		});
		return () => observer.disconnect();
	}, [
		active?.triggerEl,
		destroyActive,
		open
	]);
	useEffect(() => {
		return () => {
			clearTimers();
		};
	}, [clearTimers]);
	const portalRoot = active?.item.getPopupContainer && active?.triggerEl ? active.item.getPopupContainer(active.triggerEl) : void 0;
	const floatingNode = /* @__PURE__ */ jsx(TooltipFloating_default, {
		arrow: active?.item.arrow,
		arrowRef,
		className: active?.item.className,
		classNames: active?.item.classNames,
		context,
		floatingStyles,
		hotkey: active?.item.hotkey,
		hotkeyProps: active?.item.hotkeyProps,
		open,
		placement: floatingPlacement,
		setFloating: refs.setFloating,
		styles: active?.item.styles,
		title: active?.item.title,
		zIndex: active?.item.zIndex
	});
	return /* @__PURE__ */ jsx(TooltipGroupApiContext.Provider, {
		value: groupApi,
		children: /* @__PURE__ */ jsxs(TooltipGroupPropsContext.Provider, {
			value: sharedProps,
			children: [children, active?.item.title && !active.item.disabled && (active.item.portalled ?? true ? /* @__PURE__ */ jsx(TooltipPortal_default, {
				root: portalRoot,
				children: floatingNode
			}) : floatingNode)]
		})
	});
};
var TooltipGroup_default = TooltipGroup;

//#endregion
export { TooltipGroup_default as default };
//# sourceMappingURL=TooltipGroup.mjs.map