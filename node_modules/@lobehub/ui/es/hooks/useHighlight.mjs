'use client';

import { getCodeLanguageByInput } from "../Highlighter/const.mjs";
import { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { useTheme, useThemeMode } from "antd-style";
import { transformerNotationDiff, transformerNotationErrorLevel, transformerNotationFocus, transformerNotationHighlight, transformerNotationWordHighlight } from "@shikijs/transformers";
import { ShikiStreamTokenizer } from "shiki-stream";
import useSWR from "swr";
import { Md5 } from "ts-md5";

//#region src/hooks/useHighlight.ts
const MD5_LENGTH_THRESHOLD = 1e4;
const loadShikiModule = () => {
	if (typeof window === "undefined") return Promise.resolve(null);
	return import("shiki");
};
const shikiModulePromise = loadShikiModule();
const loadShiki = () => {
	return shikiModulePromise.then((mod) => mod?.codeToHtml ?? null);
};
const shikiPromise = loadShiki();
const escapeHtml = (str) => {
	return str.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll("\"", "&quot;").replaceAll("'", "&#039;");
};
const tokensToLineTokens = (tokens) => {
	if (!tokens.length) return [[]];
	const lines = [[]];
	let currentLine = lines[0];
	const startNewLine = () => {
		currentLine = [];
		lines.push(currentLine);
	};
	tokens.forEach((token) => {
		const content = token.content ?? "";
		if (content === "\n") {
			startNewLine();
			return;
		}
		if (!content.includes("\n")) {
			currentLine.push(token);
			return;
		}
		const segments = content.split("\n");
		segments.forEach((segment, index) => {
			if (segment) currentLine.push({
				...token,
				content: segment
			});
			if (index < segments.length - 1) startNewLine();
		});
	});
	if (lines.length === 0) return [[]];
	return lines;
};
const createPreStyle = (bg, fg) => {
	if (!bg && !fg) return void 0;
	return {
		backgroundColor: bg,
		color: fg
	};
};
const useStreamingHighlighter = (text, options) => {
	const { colorReplacements, enabled, language, theme } = options;
	const [result, setResult] = useState();
	const tokenizerRef = useRef(null);
	const previousTextRef = useRef("");
	const safeText = text ?? "";
	const latestTextRef = useRef(safeText);
	const preStyleRef = useRef(void 0);
	const colorReplacementsRef = useRef(colorReplacements);
	const linesRef = useRef([[]]);
	useEffect(() => {
		latestTextRef.current = safeText;
	}, [safeText]);
	useEffect(() => {
		colorReplacementsRef.current = colorReplacements;
	}, [colorReplacements]);
	const setStreamingResult = useCallback((rawLines) => {
		const previousLines = linesRef.current;
		const mergedLines = rawLines.map((line, index) => {
			const previousLine = previousLines[index];
			if (previousLine && previousLine.length === line.length && previousLine.every((token, tokenIndex) => token === line[tokenIndex])) return previousLine;
			return line;
		});
		linesRef.current = mergedLines;
		setResult({
			colorReplacements: colorReplacementsRef.current,
			lines: mergedLines,
			preStyle: preStyleRef.current
		});
	}, []);
	const updateTokens = useCallback(async (nextText, forceReset = false) => {
		const tokenizer = tokenizerRef.current;
		if (!tokenizer) return;
		if (forceReset) {
			tokenizer.clear();
			previousTextRef.current = "";
		}
		const previousText = previousTextRef.current;
		let chunk = nextText;
		if (!forceReset && nextText.startsWith(previousText)) chunk = nextText.slice(previousText.length);
		else if (!forceReset) tokenizer.clear();
		previousTextRef.current = nextText;
		if (!chunk) {
			const mergedTokens = [...tokenizer.tokensStable, ...tokenizer.tokensUnstable];
			setStreamingResult(mergedTokens.length ? tokensToLineTokens(mergedTokens) : [[]]);
			return;
		}
		try {
			await tokenizer.enqueue(chunk);
			setStreamingResult(tokensToLineTokens([...tokenizer.tokensStable, ...tokenizer.tokensUnstable]));
		} catch (error) {
			console.error("Streaming highlighting failed:", error);
		}
	}, [setStreamingResult]);
	useEffect(() => {
		if (!enabled) {
			tokenizerRef.current?.clear();
			tokenizerRef.current = null;
			previousTextRef.current = "";
			preStyleRef.current = void 0;
			linesRef.current = [[]];
			setResult(void 0);
			return;
		}
		let cancelled = false;
		(async () => {
			const mod = await shikiModulePromise;
			if (!mod || cancelled) return;
			try {
				const highlighter = await mod.getSingletonHighlighter({
					langs: language ? [language] : [],
					themes: [theme]
				});
				if (!highlighter || cancelled) return;
				tokenizerRef.current = new ShikiStreamTokenizer({
					highlighter,
					lang: language,
					theme
				});
				previousTextRef.current = "";
				linesRef.current = [[]];
				const themeInfo = highlighter.getTheme(theme);
				preStyleRef.current = createPreStyle(themeInfo?.bg, themeInfo?.fg);
				const currentText = latestTextRef.current;
				if (currentText) await updateTokens(currentText, true);
				else setStreamingResult([[]]);
			} catch (error) {
				console.error("Streaming highlighter initialization failed:", error);
			}
		})();
		return () => {
			cancelled = true;
			tokenizerRef.current?.clear();
			tokenizerRef.current = null;
			previousTextRef.current = "";
		};
	}, [
		enabled,
		language,
		setStreamingResult,
		theme,
		updateTokens
	]);
	useEffect(() => {
		if (!enabled) return;
		if (!tokenizerRef.current) return;
		updateTokens(safeText);
	}, [
		enabled,
		safeText,
		updateTokens
	]);
	return result;
};
const useHighlight = (text, { language, enableTransformer, theme: builtinTheme, streaming }) => {
	const { isDarkMode } = useThemeMode();
	const theme = useTheme();
	const safeText = text ?? "";
	const lang = (language ?? "plaintext").toLowerCase();
	const matchedLanguage = useMemo(() => getCodeLanguageByInput(lang), [lang]);
	const transformers = useMemo(() => {
		if (!enableTransformer) return;
		return [
			transformerNotationDiff(),
			transformerNotationHighlight(),
			transformerNotationWordHighlight(),
			transformerNotationFocus(),
			transformerNotationErrorLevel()
		];
	}, [enableTransformer]);
	const colorReplacements = useMemo(() => ({
		"slack-dark": {
			"#4ec9b0": theme.yellow,
			"#569cd6": theme.colorError,
			"#6a9955": theme.gray,
			"#9cdcfe": theme.colorText,
			"#b5cea8": theme.purple10,
			"#c586c0": theme.colorInfo,
			"#ce9178": theme.colorSuccess,
			"#dcdcaa": theme.colorWarning,
			"#e6e6e6": theme.colorText
		},
		"slack-ochin": {
			"#002339": theme.colorText,
			"#0444ac": theme.geekblue,
			"#0991b6": theme.colorError,
			"#174781": theme.purple10,
			"#2f86d2": theme.colorText,
			"#357b42": theme.gray,
			"#7b30d0": theme.colorInfo,
			"#7eb233": theme.colorWarningTextActive,
			"#a44185": theme.colorSuccess,
			"#dc3eb7": theme.yellow11
		}
	}), [theme]);
	const cacheKey = useMemo(() => {
		const hash = safeText.length < MD5_LENGTH_THRESHOLD ? safeText : Md5.hashStr(safeText);
		return [
			matchedLanguage,
			builtinTheme || (isDarkMode ? "d" : "l"),
			hash
		].filter(Boolean).join("-");
	}, [
		safeText,
		matchedLanguage,
		isDarkMode,
		builtinTheme
	]);
	const response = useSWR(streaming ? null : cacheKey, async () => {
		try {
			const codeToHtml = await shikiPromise;
			if (!codeToHtml) return safeText;
			return await codeToHtml(safeText, {
				colorReplacements: builtinTheme ? void 0 : colorReplacements,
				lang: matchedLanguage,
				theme: builtinTheme || (isDarkMode ? "slack-dark" : "slack-ochin"),
				transformers
			});
		} catch (error) {
			console.error("Advanced rendering failed:", error);
			try {
				const codeToHtml = await shikiPromise;
				if (!codeToHtml) return safeText;
				return await codeToHtml(safeText, {
					lang: matchedLanguage,
					theme: isDarkMode ? "dark-plus" : "light-plus"
				});
			} catch {
				return `<pre class="fallback"><code>${escapeHtml(safeText)}</code></pre>`;
			}
		}
	}, {
		dedupingInterval: 3e3,
		errorRetryCount: 2,
		revalidateOnFocus: false,
		revalidateOnReconnect: false
	});
	const effectiveTheme = builtinTheme || (isDarkMode ? "slack-dark" : "slack-ochin");
	const streamingResult = useStreamingHighlighter(safeText, {
		colorReplacements: builtinTheme ? void 0 : colorReplacements[effectiveTheme],
		enabled: streaming,
		language: matchedLanguage,
		theme: effectiveTheme
	});
	return {
		...response,
		colorReplacements,
		streaming: streamingResult
	};
};

//#endregion
export { useHighlight };
//# sourceMappingURL=useHighlight.mjs.map