'use client';

import Center_default from "../Flex/Center.mjs";
import Icon_default from "../Icon/Icon.mjs";
import { useStyles } from "./style.mjs";
import { reversePlacement } from "./utils.mjs";
import { memo, use, useCallback, useEffect, useMemo, useReducer, useRef, useTransition } from "react";
import { jsx, jsxs } from "react/jsx-runtime";
import { ConfigProvider } from "antd";
import useMergeState from "use-merge-value";
import { cva } from "class-variance-authority";
import { useHover } from "ahooks";
import { ChevronDown, ChevronLeft, ChevronRight, ChevronUp } from "lucide-react";
import { Resizable } from "re-resizable";

//#region src/DraggablePanel/DraggablePanel.tsx
const DEFAULT_HEIGHT = 180;
const DEFAULT_WIDTH = 280;
const DEFAULT_HEADER_HEIGHT = 0;
const DEFAULT_PIN = true;
const DEFAULT_MODE = "fixed";
const DEFAULT_EXPANDABLE = true;
const DEFAULT_EXPAND = true;
const DEFAULT_SHOW_HANDLE_WIDE_AREA = true;
function draggablePanelReducer(state, action) {
	switch (action.type) {
		case "START_RESIZE": return {
			...state,
			isResizing: true,
			showExpand: false
		};
		case "STOP_RESIZE": return {
			...state,
			isResizing: false,
			showExpand: true
		};
		case "SET_SHOW_EXPAND": return {
			...state,
			showExpand: action.payload
		};
		default: return state;
	}
}
const DraggablePanel = memo(({ headerHeight = DEFAULT_HEADER_HEIGHT, fullscreen, maxHeight, pin = DEFAULT_PIN, mode = DEFAULT_MODE, children, placement = "right", resize, style, showBorder = true, showHandleHighlight = false, showHandleWideArea = DEFAULT_SHOW_HANDLE_WIDE_AREA, backgroundColor, size, defaultSize: customizeDefaultSize, minWidth, minHeight, maxWidth, onSizeChange, onSizeDragging, expandable = DEFAULT_EXPANDABLE, expand, defaultExpand = DEFAULT_EXPAND, onExpandChange, className, showHandleWhenCollapsed, destroyOnClose, styles: customStyles, classNames, dir }) => {
	const ref = useRef(null);
	const isHovering = useHover(ref);
	const isVertical = placement === "top" || placement === "bottom";
	const [isPending, startTransition] = useTransition();
	const hoverTimeoutRef = useRef(void 0);
	const { direction: antdDirection } = use(ConfigProvider.ConfigContext);
	const direction = dir ?? antdDirection;
	const internalPlacement = useMemo(() => {
		return direction === "rtl" && ["left", "right"].includes(placement) ? placement === "left" ? "right" : "left" : placement;
	}, [direction, placement]);
	const { styles, cx } = useStyles({
		backgroundColor,
		headerHeight,
		showBorder,
		showHandleWideArea
	});
	const [isExpand, setIsExpand] = useMergeState(defaultExpand, {
		onChange: onExpandChange,
		value: expand
	});
	const [state, dispatch] = useReducer(draggablePanelReducer, {
		isResizing: false,
		showExpand: true
	});
	useEffect(() => {
		if (pin) return;
		if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);
		if (isHovering && !isExpand) startTransition(() => {
			setIsExpand(true);
		});
		else if (!isHovering && isExpand) hoverTimeoutRef.current = setTimeout(() => {
			startTransition(() => {
				setIsExpand(false);
			});
		}, 150);
	}, [
		pin,
		isHovering,
		isExpand,
		setIsExpand
	]);
	useEffect(() => {
		return () => {
			if (hoverTimeoutRef.current) clearTimeout(hoverTimeoutRef.current);
		};
	}, []);
	const canResizing = resize !== false && isExpand;
	const variants = useMemo(() => cva(styles.root, {
		compoundVariants: [
			{
				class: styles.bottomFloat,
				mode: "float",
				placement: "bottom"
			},
			{
				class: styles.topFloat,
				mode: "float",
				placement: "top"
			},
			{
				class: styles.leftFloat,
				mode: "float",
				placement: "left"
			},
			{
				class: styles.rightFloat,
				mode: "float",
				placement: "right"
			}
		],
		variants: {
			placement: {
				top: isExpand && styles.borderBottom,
				right: isExpand && styles.borderLeft,
				bottom: isExpand && styles.borderTop,
				left: isExpand && styles.borderRight
			},
			mode: {
				fixed: styles.fixed,
				float: null
			}
		}
	}), [styles, isExpand]);
	const handleVariants = useMemo(() => cva(styles.handleRoot, { variants: { placement: {
		bottom: styles.handleBottom,
		left: styles.handleLeft,
		right: styles.handleRight,
		top: styles.handleTop
	} } }), [styles]);
	const toggleVariants = useMemo(() => cva(styles.toggleRoot, { variants: { placement: {
		bottom: styles.toggleTop,
		left: styles.toggleRight,
		right: styles.toggleLeft,
		top: styles.toggleBottom
	} } }), [styles]);
	const resizing = useMemo(() => ({
		bottom: false,
		bottomLeft: false,
		bottomRight: false,
		left: false,
		right: false,
		top: false,
		topLeft: false,
		topRight: false,
		[reversePlacement(internalPlacement)]: true,
		...resize
	}), [internalPlacement, resize]);
	const defaultSize = useMemo(() => {
		if (isVertical) return {
			height: DEFAULT_HEIGHT,
			width: "100%",
			...customizeDefaultSize
		};
		return {
			height: "100%",
			width: DEFAULT_WIDTH,
			...customizeDefaultSize
		};
	}, [isVertical, customizeDefaultSize]);
	const sizeProps = useMemo(() => {
		if (!isExpand) return isVertical ? {
			minHeight: 0,
			size: { height: 0 }
		} : {
			minWidth: 0,
			size: { width: 0 }
		};
		return {
			defaultSize,
			maxHeight: typeof maxHeight === "number" ? Math.max(maxHeight, 0) : maxHeight,
			maxWidth: typeof maxWidth === "number" ? Math.max(maxWidth, 0) : maxWidth,
			minHeight: typeof minHeight === "number" ? Math.max(minHeight, 0) : minHeight,
			minWidth: typeof minWidth === "number" ? Math.max(minWidth, 0) : minWidth,
			size
		};
	}, [
		isExpand,
		isVertical,
		defaultSize,
		maxHeight,
		maxWidth,
		minHeight,
		minWidth,
		size
	]);
	const Arrow = useMemo(() => {
		switch (internalPlacement) {
			case "top": return ChevronDown;
			case "bottom": return ChevronUp;
			case "right": return ChevronLeft;
			case "left": return ChevronRight;
			default: return ChevronLeft;
		}
	}, [internalPlacement]);
	const toggleExpand = useCallback(() => {
		if (!expandable) return;
		startTransition(() => {
			setIsExpand(!isExpand);
		});
	}, [
		expandable,
		isExpand,
		setIsExpand
	]);
	const handle = useMemo(() => /* @__PURE__ */ jsx(Center_default, {
		className: toggleVariants({ placement: internalPlacement }),
		style: { opacity: isExpand ? pin ? void 0 : 0 : showHandleWhenCollapsed ? 1 : 0 },
		children: /* @__PURE__ */ jsx(Center_default, {
			className: classNames?.handle,
			onClick: toggleExpand,
			style: customStyles?.handle,
			children: /* @__PURE__ */ jsx(Icon_default, {
				className: styles.handlerIcon,
				icon: Arrow,
				size: 16,
				style: {
					marginBottom: internalPlacement === "top" ? 4 : 0,
					marginLeft: internalPlacement === "right" ? 4 : 0,
					marginRight: internalPlacement === "left" ? 4 : 0,
					marginTop: internalPlacement === "bottom" ? 4 : 0,
					transform: `rotate(${isExpand ? 180 : 0}deg)`,
					transition: "transform 0.3s ease"
				}
			})
		})
	}), [
		toggleVariants,
		internalPlacement,
		isExpand,
		pin,
		showHandleWhenCollapsed,
		classNames?.handle,
		toggleExpand,
		customStyles?.handle,
		styles.handlerIcon,
		Arrow
	]);
	const handleResize = useCallback((_, _direction, reference_, delta) => {
		onSizeDragging?.(delta, {
			height: reference_.style.height,
			width: reference_.style.width
		});
	}, [onSizeDragging]);
	const handleResizeStart = useCallback(() => {
		dispatch({ type: "START_RESIZE" });
	}, []);
	const handleResizeStop = useCallback((e, direction$1, reference_, delta) => {
		dispatch({ type: "STOP_RESIZE" });
		onSizeChange?.(delta, {
			height: reference_.style.height,
			width: reference_.style.width
		});
	}, [onSizeChange]);
	const inner = useMemo(() => /* @__PURE__ */ jsx(Resizable, {
		...sizeProps,
		className: cx(styles.panel, classNames?.content),
		enable: canResizing ? resizing : void 0,
		handleClasses: canResizing ? { [reversePlacement(internalPlacement)]: cx(handleVariants({ placement: reversePlacement(internalPlacement) }), showHandleHighlight && styles.handleHighlight) } : {},
		onResize: handleResize,
		onResizeStart: handleResizeStart,
		onResizeStop: handleResizeStop,
		style: {
			opacity: isPending ? .95 : 1,
			transition: state.isResizing ? "unset" : void 0,
			...style
		},
		children
	}), [
		sizeProps,
		styles.panel,
		classNames?.content,
		canResizing,
		resizing,
		internalPlacement,
		handleVariants,
		showHandleHighlight,
		styles.handleHighlight,
		handleResize,
		handleResizeStart,
		handleResizeStop,
		state.isResizing,
		isPending,
		style,
		children,
		cx
	]);
	if (fullscreen) return /* @__PURE__ */ jsx("div", {
		className: cx(styles.fullscreen, className),
		children
	});
	return /* @__PURE__ */ jsxs("aside", {
		className: cx(variants({
			mode,
			placement: internalPlacement
		}), className),
		dir,
		ref,
		children: [expandable && state.showExpand && handle, destroyOnClose ? isExpand && inner : inner]
	});
}, (prevProps, nextProps) => {
	return prevProps.placement === nextProps.placement && prevProps.mode === nextProps.mode && prevProps.expand === nextProps.expand && prevProps.pin === nextProps.pin && prevProps.fullscreen === nextProps.fullscreen && prevProps.size === nextProps.size && prevProps.defaultSize === nextProps.defaultSize && prevProps.minWidth === nextProps.minWidth && prevProps.minHeight === nextProps.minHeight && prevProps.maxWidth === nextProps.maxWidth && prevProps.maxHeight === nextProps.maxHeight && prevProps.expandable === nextProps.expandable && prevProps.resize === nextProps.resize && prevProps.showHandleWhenCollapsed === nextProps.showHandleWhenCollapsed && prevProps.destroyOnClose === nextProps.destroyOnClose && prevProps.showBorder === nextProps.showBorder && prevProps.showHandleHighlight === nextProps.showHandleHighlight && prevProps.showHandleWideArea === nextProps.showHandleWideArea && prevProps.backgroundColor === nextProps.backgroundColor && prevProps.className === nextProps.className && prevProps.dir === nextProps.dir && prevProps.headerHeight === nextProps.headerHeight && prevProps.onSizeChange === nextProps.onSizeChange && prevProps.onSizeDragging === nextProps.onSizeDragging && prevProps.onExpandChange === nextProps.onExpandChange && prevProps.children === nextProps.children;
});
DraggablePanel.displayName = "DraggablePanel";
var DraggablePanel_default = DraggablePanel;

//#endregion
export { DraggablePanel_default as default };
//# sourceMappingURL=DraggablePanel.mjs.map