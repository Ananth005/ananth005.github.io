{"version":3,"file":"remarkGfmPlus.mjs","names":["textNodes: any[]","node"],"sources":["../../../src/Markdown/plugins/remarkGfmPlus.ts"],"sourcesContent":["import { visit } from 'unist-util-visit';\n\ninterface RemarkGfmPlusOptions {\n  allowHtmlTags?: string[];\n}\n\nconst DEFAULT_ALLOW_HTML_TAGS = [\n  'sub',\n  'sup',\n  'ins',\n  'kbd',\n  'b',\n  'strong',\n  'i',\n  'em',\n  'mark',\n  'del',\n  'u',\n];\n\nexport const remarkGfmPlus = (options: RemarkGfmPlusOptions = {}) => {\n  const { allowHtmlTags = DEFAULT_ALLOW_HTML_TAGS } = options;\n\n  return (tree: any) => {\n    // 遍历所有父节点，查找分离的HTML标签模式\n    visit(tree, (node: any) => {\n      if (!node.children || !Array.isArray(node.children)) return;\n\n      const children = node.children;\n      let i = 0;\n\n      while (i < children.length) {\n        const currentNode = children[i];\n\n        // 查找开始标签\n        if (currentNode.type === 'html' && currentNode.value) {\n          const tagPattern = `^<(${allowHtmlTags.join('|')})>$`;\n          const startTagMatch = currentNode.value.match(new RegExp(tagPattern));\n\n          if (startTagMatch) {\n            const tagName = startTagMatch[1];\n\n            // 查找对应的结束标签\n            let endIndex = -1;\n            const textNodes: any[] = [];\n\n            for (let j = i + 1; j < children.length; j++) {\n              const nextNode = children[j];\n\n              if (nextNode.type === 'html' && nextNode.value === `</${tagName}>`) {\n                endIndex = j;\n                break;\n              } else if (nextNode.type === 'text') {\n                textNodes.push(nextNode);\n              } else {\n                // 如果遇到其他类型的节点，停止查找\n                break;\n              }\n            }\n\n            if (endIndex !== -1) {\n              // 收集所有文本内容\n              const textContent = textNodes.map((node) => node.value).join('');\n\n              // 创建新的自定义节点\n              const newNode = {\n                children: [{ type: 'text', value: textContent }],\n                data: {\n                  hName: tagName,\n                  hProperties: {},\n                },\n                type: tagName,\n              };\n\n              // 替换从开始标签到结束标签的所有节点\n              const removeCount = endIndex - i + 1;\n              children.splice(i, removeCount, newNode);\n\n              // 继续处理下一个节点\n              i++;\n              continue;\n            }\n          }\n        }\n\n        i++;\n      }\n    });\n\n    // 保留对文本节点中完整HTML标签的处理（作为备用）\n    visit(tree, 'text', (node, index = 0, parent) => {\n      if (!node.value || typeof node.value !== 'string') return;\n\n      // 处理HTML实体编码的标签\n      const encodedTagPattern = `&lt;(${allowHtmlTags.join('|')})&gt;(.*?)&lt;\\\\/\\\\1&gt;`;\n      const encodedTagRegex = new RegExp(encodedTagPattern, 'gi');\n      const text = node.value;\n\n      if (!encodedTagRegex.test(text)) return;\n\n      // 重置正则表达式的 lastIndex\n      encodedTagRegex.lastIndex = 0;\n\n      const newNodes = [];\n      let lastIndex = 0;\n      let match;\n\n      while ((match = encodedTagRegex.exec(text)) !== null) {\n        const [fullMatch, tagName, content] = match;\n        const startIndex = match.index;\n\n        // 添加匹配前的文本\n        if (startIndex > lastIndex) {\n          newNodes.push({\n            type: 'text',\n            value: text.slice(lastIndex, startIndex),\n          });\n        }\n\n        // 添加特殊标签节点\n        newNodes.push({\n          children: [{ type: 'text', value: content }],\n          data: {\n            hName: tagName,\n            hProperties: {},\n          },\n          type: tagName,\n        });\n\n        lastIndex = startIndex + fullMatch.length;\n      }\n\n      // 添加剩余文本\n      if (lastIndex < text.length) {\n        newNodes.push({\n          type: 'text',\n          value: text.slice(lastIndex),\n        });\n      }\n\n      // 替换当前节点\n      if (newNodes.length > 0 && parent) {\n        parent.children.splice(index, 1, ...newNodes);\n        return index + newNodes.length - 1;\n      }\n    });\n  };\n};\n"],"mappings":";;;AAMA,MAAM,0BAA0B;CAC9B;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACD;AAED,MAAa,iBAAiB,UAAgC,EAAE,KAAK;CACnE,MAAM,EAAE,gBAAgB,4BAA4B;AAEpD,SAAQ,SAAc;AAEpB,QAAM,OAAO,SAAc;AACzB,OAAI,CAAC,KAAK,YAAY,CAAC,MAAM,QAAQ,KAAK,SAAS,CAAE;GAErD,MAAM,WAAW,KAAK;GACtB,IAAI,IAAI;AAER,UAAO,IAAI,SAAS,QAAQ;IAC1B,MAAM,cAAc,SAAS;AAG7B,QAAI,YAAY,SAAS,UAAU,YAAY,OAAO;KACpD,MAAM,aAAa,MAAM,cAAc,KAAK,IAAI,CAAC;KACjD,MAAM,gBAAgB,YAAY,MAAM,MAAM,IAAI,OAAO,WAAW,CAAC;AAErE,SAAI,eAAe;MACjB,MAAM,UAAU,cAAc;MAG9B,IAAI,WAAW;MACf,MAAMA,YAAmB,EAAE;AAE3B,WAAK,IAAI,IAAI,IAAI,GAAG,IAAI,SAAS,QAAQ,KAAK;OAC5C,MAAM,WAAW,SAAS;AAE1B,WAAI,SAAS,SAAS,UAAU,SAAS,UAAU,KAAK,QAAQ,IAAI;AAClE,mBAAW;AACX;kBACS,SAAS,SAAS,OAC3B,WAAU,KAAK,SAAS;WAGxB;;AAIJ,UAAI,aAAa,IAAI;OAKnB,MAAM,UAAU;QACd,UAAU,CAAC;SAAE,MAAM;SAAQ,OAJT,UAAU,KAAK,WAASC,OAAK,MAAM,CAAC,KAAK,GAAG;SAIf,CAAC;QAChD,MAAM;SACJ,OAAO;SACP,aAAa,EAAE;SAChB;QACD,MAAM;QACP;OAGD,MAAM,cAAc,WAAW,IAAI;AACnC,gBAAS,OAAO,GAAG,aAAa,QAAQ;AAGxC;AACA;;;;AAKN;;IAEF;AAGF,QAAM,MAAM,SAAS,MAAM,QAAQ,GAAG,WAAW;AAC/C,OAAI,CAAC,KAAK,SAAS,OAAO,KAAK,UAAU,SAAU;GAGnD,MAAM,oBAAoB,QAAQ,cAAc,KAAK,IAAI,CAAC;GAC1D,MAAM,kBAAkB,IAAI,OAAO,mBAAmB,KAAK;GAC3D,MAAM,OAAO,KAAK;AAElB,OAAI,CAAC,gBAAgB,KAAK,KAAK,CAAE;AAGjC,mBAAgB,YAAY;GAE5B,MAAM,WAAW,EAAE;GACnB,IAAI,YAAY;GAChB,IAAI;AAEJ,WAAQ,QAAQ,gBAAgB,KAAK,KAAK,MAAM,MAAM;IACpD,MAAM,CAAC,WAAW,SAAS,WAAW;IACtC,MAAM,aAAa,MAAM;AAGzB,QAAI,aAAa,UACf,UAAS,KAAK;KACZ,MAAM;KACN,OAAO,KAAK,MAAM,WAAW,WAAW;KACzC,CAAC;AAIJ,aAAS,KAAK;KACZ,UAAU,CAAC;MAAE,MAAM;MAAQ,OAAO;MAAS,CAAC;KAC5C,MAAM;MACJ,OAAO;MACP,aAAa,EAAE;MAChB;KACD,MAAM;KACP,CAAC;AAEF,gBAAY,aAAa,UAAU;;AAIrC,OAAI,YAAY,KAAK,OACnB,UAAS,KAAK;IACZ,MAAM;IACN,OAAO,KAAK,MAAM,UAAU;IAC7B,CAAC;AAIJ,OAAI,SAAS,SAAS,KAAK,QAAQ;AACjC,WAAO,SAAS,OAAO,OAAO,GAAG,GAAG,SAAS;AAC7C,WAAO,QAAQ,SAAS,SAAS;;IAEnC"}